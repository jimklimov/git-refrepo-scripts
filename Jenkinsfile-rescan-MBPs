#!/usr/bin/env groovy

import jenkins.model.*
import hudson.model.*
import hudson.util.PersistedList
import jenkins.branch.*

@NonCPS
def parallelSubtasks(String verbose) {
//    def subbuilds = [:]
    def subbuilds = ""
    def jobs = Jenkins.instance.getAllItems()

    jobs.each { j ->
//    for (j in jobs) {
//    for (int i = 0; i < jobs.size(); i++) {
//        def j = jobs[i];

        if (j instanceof com.cloudbees.hudson.plugins.folder.Folder) {
            if (verbose.equals("true")) {
                echo 'Ignoring JOB which is a com.cloudbees.hudson.plugins.folder.Folder : ' + j.fullName
            }
            return
        }
        if (j instanceof jenkins.branch.OrganizationFolder) {
            if (verbose.equals("true")) {
                echo 'Ignoring JOB which is a jenkins.branch.OrganizationFolder : ' + j.fullName
            }
            return
        }
        if (! (j instanceof org.jenkinsci.plugins.workflow.multibranch.WorkflowMultiBranchProject) ) {
            if (verbose.equals("true")) {
                echo 'Ignoring JOB which is not an MBP: ' + j.fullName
            }
            return;
        }
        if ( ! j.fullName.contains("/") ) {
            echo 'Ignoring MBP JOB which is not under a (organization) folder, so has and hopefully honours a schedule of its own: ' + j.fullName
            return;
        }
        // TODO: Determine that MBP's schedule and only fire below if it is "once a day" (hardcoded)?

/*
        subbuilds["${j.fullName}"] = {
            stage("Scan ${j.fullName}") {
                steps {
                    echo "Rescanning '${j.fullName}' ..."
//                    build job: "${j.fullName}", quietPeriod: 0, wait: true, propagate: true
                }
            }
        } // end of def subbuilds[j.fullName]
*/

        subbuilds += """
            stage("Scan ${j.fullName}") {
                steps {
                    echo "Rescanning '${j.fullName}' ..."
//                    build job: "${j.fullName}", quietPeriod: 0, wait: true, propagate: true
                }
            }
"""

    } // jobs.each() clause

    // Unleash hell, wait for results
//    parallel subbuilds

    subbuilds = """
@NonCPS
def run_parallelscan() {
    parallel {
        ${subbuilds}
    }
}
"""

    echo subbuilds

    echo "Write the temp-file..."
    sh "mkdir -p vars && echo '${subbuilds}' > 'vars/parallelscan.groovy'"
//    writeFile file: 'vars/parallelscan.groovy', text: "${subbuilds}"

    echo "Load the temp-file..."
//    load 'vars/parallelscan.groovy'
    library 'parallelscan'
    echo "Loaded temp-file above"
    run_parallelscan()
    echo "Execed temp-file above"
}


pipeline {
    options {
/*
        description("This job runs regularly to find and rescan multibranch pipeline jobs (e.g. generated via organization folders) to add monitoring of new PRs (and disable monitoring of merged PRs) in a timely fashion.")
*/
        disableConcurrentBuilds()
        disableResume()
        durabilityHint('PERFORMANCE_OPTIMIZED')
        buildDiscarder(logRotator(numToKeepStr: '10'))
        skipDefaultCheckout true
    }
    triggers {
        cron('H/15 * * * *')
    }
    agent {label "master||master-real||master-worker"}
    parameters {
        booleanParam (
            defaultValue: false,
            description: 'Print found and skipped items?',
            name: 'JOBLIST_VERBOSE'
        )
    }
    stages {
        stage('Scan MBP jobs') {
//            when { expression (env.BRANCH_NAME == "master") }
            steps {
                milestone 1
                script {
                    parallelSubtasks( "${params.JOBLIST_VERBOSE}" )

    echo "2. Load the temp-file..."
    load 'vars/parallelscan.groovy'
//    library 'parallelscan'
    echo "2. Loaded temp-file above"
    run_parallelscan()
    echo "2. Execed temp-file above"

                } // script clause
            } // steps clause
        }
    }
}
