#!/usr/bin/env groovy

// Jenkinsfile-rescan-MBPs
// (C) 2018 by Jim Klimov
// This Jenkinsfile makes-believe it is a Declarative pipeline for
// the sake of commonality of our pipeline scripts (build args,
// various options and stuff), but in fact this is a scripted
// pipeline most of the way.
// Its job is to find MultiBranchPipeline items spawned inside an
// organization folder and issue a rescan request (build operation),
// so we can detect new or closed PRs and branches quickly (due to
// JENKINS-49526 MBPs are otherwise polled once a day, hardcoded).

import jenkins.model.*
import hudson.model.*
import hudson.util.PersistedList
import jenkins.branch.*

// This shared array variable will be populated with the list of parallel stages
def scan_stages = [:]

@NonCPS
def parallelSubtasks(String verbose, String regexSubset) {
    def subbuilds = [:]
    def jobs = Jenkins.instance.getAllItems()

    jobs.each { j ->
        if (j instanceof com.cloudbees.hudson.plugins.folder.Folder) {
            if (verbose.equals("true")) {
                echo 'Ignoring JOB which is a com.cloudbees.hudson.plugins.folder.Folder : ' + j.fullName
            }
            return
        }
        if (j instanceof jenkins.branch.OrganizationFolder) {
            if (verbose.equals("true")) {
                echo 'Ignoring JOB which is a jenkins.branch.OrganizationFolder : ' + j.fullName
            }
            return
        }
        if (! (j instanceof org.jenkinsci.plugins.workflow.multibranch.WorkflowMultiBranchProject) ) {
            if (verbose.equals("true")) {
                echo 'Ignoring JOB which is not an MBP: ' + j.fullName
            }
            return;
        }
        if ( ! j.fullName.contains("/") ) {
            echo 'Ignoring MBP JOB which is not under a (organization) folder, so has and hopefully honours a schedule of its own: ' + j.fullName
            return;
        }
        if ( ! regexSubset.equals("") ) {
            if ( ! ( j.fullName ==~ regexSubset ) ) {
                echo "Ignoring MBP JOB whose name '${j.fullName}' did not match specified regex of interesting jobs to rescan '${regexSubset}'"
                return;
            }
        }
/*
        if ( j.fullName.contains("SPECIAL/snowflake") ) {
            echo 'Ignoring MBP JOB which for some reason is rebuilt every time we touch it: ' + j.fullName
            return;
        }
*/
        // TODO: Determine that MBP's schedule and only fire below if it is "once a day" (hardcoded)?

        subbuilds["${j.fullName}"] = {
            stage("Scan ${j.fullName}") {
                // Per non-declarative pipeline syntax, no steps{} here
                    echo "Rescanning '${j.fullName}' ..."
                    // Jenkins refuses to "wait" for this type of job...
                    // TODO: Sleep-poll the results (and logs?) of the
                    // spawned child jobs.
                    try {
                        def bbb = build job: "${j.fullName}", quietPeriod: 0, wait: false, propagate: true
                    } catch (Exception e) {
                        // e.g. a disabled repo, like one where a Jenkinsfile
                        // script existed earlier but was removed
                        echo "Failed to trigger scan for ${j.fullName}, skipped"
                    }
            }
        } // end of def subbuilds[j.fullName]

    } // jobs.each() clause

    return subbuilds
}


// A declarative pipeline shiny wrapper (we need it
// for common ways of autosetup and params, mostly)
pipeline {
    options {
/*
        description("This job runs regularly to find and rescan multibranch pipeline jobs (e.g. generated via organization folders) to add monitoring of new PRs (and disable monitoring of merged PRs) in a timely fashion.")
*/
        disableConcurrentBuilds()
        disableResume()
        durabilityHint('PERFORMANCE_OPTIMIZED')
        buildDiscarder(logRotator(numToKeepStr: '10'))
        skipDefaultCheckout true
    }
    triggers {
        cron('H/15 * * * *')
    }
    agent {label "master||master-real||master-worker"}
    parameters {
        booleanParam (
            defaultValue: false,
            description: 'Print found and skipped items?',
            name: 'JOBLIST_VERBOSE'
        )
        string (
            defaultValue: '',
            description: 'Groovy regex for constraining a list of rescans to schedule (if not empty, then only matching MBP job names are scanned)',
            name: 'JOBLIST_SUBSET')
    }
    stages {
        stage('Single-exec milestone') {
            steps {
                milestone 1
            } // steps clause
        }
    }
}

// Non-declarative pipeline payload.
// This code below does not work inside a pipeline{} stage{}
// clause nor in the post{} clause - not even with the added
// try/catches for exceptions all around.
// Curiously, when this pipeline job is built by hand
// or triggered by timer, it fails with lots of CPS and
// marshalling exception messages in the end. Replaying
// the same groovy script with no changes just works.
try {
    echo "DISCOVERING JOBS..."
    scan_stages = parallelSubtasks( "${params.JOBLIST_VERBOSE}", "${params.JOBLIST_SUBSET}" )
} catch (java.io.NotSerializableException e) {
    echo "Ignoring NotSerializableException during parallelSubtasks()"
} catch (Exception e) {
    echo "Failed to find jobs or set up parallel scans"
    currentBuild.result = 'FAILED'
    manager.buildAborted()
}

try {
    echo "SCHEDULING RESCANS..."
    parallel scan_stages
    echo "SCHEDULING OF RESCANS COMPLETED"
} catch (java.io.NotSerializableException e) {
    echo "Ignoring NotSerializableException during parallelized work"
} catch (Exception e) {
    echo "Failed to trigger parallel scans"
    currentBuild.result = 'FAILED'
    manager.buildAborted()
}
